September 14, 2004
------------------
After discussions with the pulsar search group, updated spec to require that
all SFT blocks share some common header info.


September 9, 2004
-----------------
Release 2.3 of reference library.  Spec updated as per comments
in SCCB_2004_09_09

August 17, 2004
---------------
First public release of version 2.2 of reference library.

LIGO Dcoument Control Center (DCC) number: T040164-00-Z

$Id$

SFT Data Format Version 2 Specification

An SFT is stored in a file.  The file is composed of concurrent SFT
BLOCKS.

Each SFT BLOCK is organized as follows:

________________________

   HEADER (48 bytes)
________________________

 ASCII COMMENT (8*n bytes)
 where n is a non-negative
 integer
________________________

  DATA (8*N bytes)
 where N is a positive
 integer
________________________


The total length of the SFT BLOCK is 48+8*n+8*N bytes.  The SFT BLOCK
may be written in either big-endian or little-endian ordering.  All
floats and doubles follow the IEEE-754 floating-point conventions.

The HEADER contains 48 bytes as follows:

_____________________________________

8 bytes REAL8  version
_____________________________________

4 bytes  INT4   gps_sec;
_____________________________________

4 bytes  INT4   gps_nsec;
_____________________________________

8 bytes  REAL8  tbase;
______________________________________

4 bytes  INT4   first_frequency_index;
______________________________________

4 bytes  INT4   nsamples;
______________________________________

8 bytes  UNSIGNED INT8   crc64;
______________________________________

2 bytes  CHAR   detector[2];
______________________________________

2 bytes  CHAR   padding[2];
______________________________________

4 bytes  INT4   comment_length;
______________________________________


The SFT blocks in a given SFT file are required to:
(0) come from the same instrument, and have:
(1) identical version numbers
(2) monotonically increasing GPS times
(3) identical values of tbase
(4) identical values of first_frequency_index
(5) identical values of nsamples
NOTE: SFT blocks in a given SFT file are in general NOT contiguous.
In other words the GPS start time of a given block may or may not
equal the GPS start time of the previous block plus the time baseline.


Note that this HEADER corresponds to the C structure below
struct SFTtag {
  REAL8  version:
  INT4   gps_sec;
  INT4   gps_nsec;
  REAL8  tbase;
  INT4   first_frequency_index;
  INT4   nsamples;
  UINT8  crc64;
  CHAR   detector[2];	
  CHAR   padding[2];
  INT4   comment_length;
} SFTheader;
when the structure is packed, ie no zero padding between fields is
allowed.  Note that several of these quantities that might be taken as
unsigned are in fact signed.  This makes it easier and less
error-prone for user applications and code to compute differences
between these quantities.

The structure of the ASCII COMMENT is comment_length==8*n arbitrary
ASCII bytes, where n is a non-negative integer.  The following rules
apply to NULL bytes appearing in ASCII COMMENT, if n is non-zero:
(1) There must be at least one NULL byte in the ASCII COMMENT
(2) If a NULL byte appears in the ASCII COMMENT, all the following
    bytes in the ASCII COMMENT must also be NULL bytes.
The reason for these two rules is so that if the ASCII comment has
nonzero length then it may always be treated as a C null-terminated
string, with no information 'hidden' after the null byte.
If the SFT comes from interferometer data, then the full channel name
used will be contained in the comment block.  If a window function is
used (see below), then the window name (along with parameters if the
name is not sufficient) of the window function will also be contained
in the comment block.

The DATA region consists of N COMPLEX8 quantities.  Each COMPLEX8 is
made of a 4-byte IEEE-754 float real part, followed by a 4-byte
IEEE-754 float imaginary part.  The packing and normalization of this
data comply with the LSC specifications for frequency-domain data.
The current version of this specification may be found at
http://www.ligo.caltech.edu/docs/T/T010095-00.pdf


version: shall be 2.0 .

    Note that SFTs produced before this specification will have this
    field set to 1.0.  Note that future versions of this specification
    will have version=3.0, 4.0, etc.  This field will always be an
    integer value that can be exactly represented as an IEEE754
    double.  If this field is not an exact integer in the range 1 to
    1000000, then software reading this data should assume that it is
    byte-swapped and take appropriate measures to reverse the byte
    ordering.  If byte swapping does NOT cause the version number
    to be an exact integer between 1 and 1000000, then the SFT does
    not comply with these specifications.

gps_sec: Integer part of the GPS time in seconds of the first sample used to make
         this SFT.

gps_nsec: GPS nanoseconds of the first sample used to make this SFT.  This
          must lie in the range from 0 to 10^9-1 inclusive.
 
tbase:    The time length in seconds of the data set used to make this SFT.
          This must be greater than zero.

    Note that if the sample interval is dt, and the number of
    time-domain samples is S, then tbase=S dt.  Note that if the data
    is produced with heterodyning, tbase still refers to the total
    time length of the data set.  Note that the frequency spacing in
    between samples (df, as defined in T010095-00) is 1.0/tbase.  If df
    can not be exactly represented as an IEEE-754 double, then the closest
    IEEE-754 double to 1.0/tbase will be the closest IEEE-754 double to df.

first_frequency_index: This is the subscript of the first complex FFT
          value that appears
          in DATA.  It's allowed range is 0 to (Nyquist_Frequency *
          tbase)/2 = S/2 inclusive.  Note: if S is odd, then in this
          document S/2 shall mean the integer part of S/2.

nsamples: The number of complex samples in DATA.  nsamples=N.  Its
          allowed range is 1 to S/2+1 inclusive

crc64: The 64-bit CRC checksum of the 48+8*n+8*N bytes that make up
       the SFT, with the 8 bytes labeled crc64 set to zero.  The
       CRC checksum will be evaluated using the
       polynomial D800000000000000 (base-16) =
       1101100000000000000000000000000000000000000000000000000000000000 (base-2).
       The primitive polynomial is x^64 + x^4 + x^3 + x + 1.
       The CRC will be initialized to all ones (~0ULL).

detector: a two-character prefix of the from 'Xn' characterizing the detector, where 
	X is a single capital letter describing the site 
		(H=Hanford, L=Livingston, G=GEO, V=Virgo, T=TAMA,...)
	n is the detector number,
	e.g. L1 for LLO, H1 for LHO4km, H2 for LHO2km, etc.
	(this follows the naming convention for the channel-name prefix
	 in the Frame-format, cf. LIGO-T970130-F-E:)  

padding:  These two bytes will be set to zero.  They are here so that all 8-byte
          quantities are byte aligned with respect to the header.  This may permit
          certain efficiencies and library usages on certain platforms/architectures.

comment_length: The number of bytes that appear in ASCII COMMENT.
          comment_length=8*n with n a non-negative integer.. Note
          that if comment_length==0 then the SFT contains no comment.


The complex quantities contained in DATA REGION are defined by the
following equations, complying with
http://www.ligo.caltech.edu/docs/T/T010095-00.pdf

The data set (with the native fundamental sample interval dt) is
denoted by x_i for i=0, ..., S-1.  The x_i are all real.  Let

    n_k = \sum_j=0^S-1 x_j exp(-2 pi i j k/S)

be the values of the DFT with LSC sign conventions.  The values in
DATA REGION are 

    data_k = dt * n_k

for k=first_frequency_index to k=first_frequency_index+nsamples-1.

[Note: the interesting range of k is from 0 to S/2 inclusive.]

The allowed range of first_frequency_index is from 0 to S/2 inclusive.

The allowed range of nsamples=N is 1 to S/2+1-first_frequency_index
inclusive.

[Here we assume that the window function is rectangular, eg each
sample is weighted by a window function whose value is 1.  If the data
IS windowed then the normalization conventions of T010095-00.pdf still
apply.]

Note that if a data stream is band-limited (for instance by filtering)
and then decimated or down-sampled, the values stored in DATA REGION
for a given set of frequency bins will be unchanged compared to those
computed with the original data set.  This is true even though the
sample interval dt' of the new downsampled data set is larger than the
original native sample time.  In fact, except for the DC (k=0) and
Nyquist (k=S/2+1) frequency bins, the power spectral density may be
written as:

   psd_k = (2/tbase) |data_k|^2 (except for k=0 or Nyquist)

EXAMPLE 1:
---------
Consider the case where the fundamental time-domain data set consists
of 16 samples, taken at a sample rate of 16 Hz.  All 16 samples are
x_0=...=x_15=1 which gives n_0=16, n_1=...=n_8=0.  Since dt=1/16, we find

data_0 = 1 + 0i
data_1 = 0
data_2 = 0
data_3 = 0
data_4 = 0
data_5 = 0
data_6 = 0
data_7 = 0
data_8 = 0

If we store only nsamples=5 frequency bins in the SFT, then DATA
REGION will contain the 40 bytes corresponding to identical values for
data_k:

data_0 = 1 + 0i
data_1 = 0
data_2 = 0
data_3 = 0
data_4 = 0

These values could be obtained by considering a subset of the original
SFT.  Alternatively they could be obtained by low-pass filtering the
original time series, and downsampling it, and using the previous
definitions.  For example if the downsampled time series had 8 samples
x_0=...=x_7=1 with a sample time of dt=1/8, then n_0=8, and
n_1=...=n_4=0.  This gives the same values as above.

EXAMPLE 2:
---------

Sinusoid function at 2 Hz x(t)= 1 *cos (2 pi 2 t)

Using again 16 samples taken at a sample rate of 16 Hz.

x_00 =  1.000000
x_01 =  0.707107
x_02 =  0.000000
x_03 = -0.707107
x_04 = -1.000000
x_05 = -0.707107
x_06 = -0.000000
x_07 =  0.707107
x_08 =  1.000000
x_09 =  0.707107
x_10 =  0.000000
x_11 = -0.707107
x_12 = -1.000000
x_13 = -0.707107
x_14 = -0.000000
x_15 =  0.707107

giving
         n_0 = n_1 =0+0i
	 n_2 = 8+0i
	 n_3 =... = n_8 = 0+0i
	 
and 	data_0 = data_1 =0+0i
 	data_2= 0.5+0i
 	data_3 = ...= data_8= 0+0i

If we down-sample the original data stream by a factor of two we get:

x_00 =  1.000000
x_01 =  0.000000
x_02 = -1.000000
x_03 = -0.000000
x_04 =  1.000000
x_05 =  0.000000
x_06 = -1.000000
x_07 = -0.000000

giving
	 n_0 = n_1 =0+0i
	 n_2 = 4+0i
	 n_3 =... = n_4 = 0+0i

and 	data_0 = data_1 =0+0i
 	data_2= 0.5+0i
 	data_3 = ...= data_4=0+0i


