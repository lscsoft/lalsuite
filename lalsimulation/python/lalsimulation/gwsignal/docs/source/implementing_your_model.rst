Implementing your model
=============================

This page provides the instructions to make your own Python model accessible through the interface.

The minimal set of ingredients are:

* A function that takes the physical parameters as input, and outputs a set of modes and the corresponding vector of times/frequencies,

* A class that inherits from the class :code:`CompactBinaryCoalescenceGenerator` implemented in the waveforms interface. This can be done in two steps, as shown below.


Develop your model
---------------------
First, you need to provide a function that takes the physical parameters as input, and outputs the times (frequencies) along with the set of gravitational wave modes or polarizations.
The implementation of this function is flexible, but you need to be consistent when you call this function from the class that links it to the interface.

For example, your mode generating function can be

.. code-block:: python

	import numpy as np

	def my_modes(m1, m2):

		m1 = m1.value
		m2 = m2.value

		M = m1 + m2
		mu = m1 * m2 / M

		size = 1000
		times = np.linspace(0., 1., num = size)

		hlm = {}
		hlm[2,2] = 1/M*np.ones(size)
		hlm[2,-2] = 1/mu*np.ones(size)
		hlm[4,4] = np.zeros(size)
		hlm[4,-4] = np.zeros(size)

		return times, hlm


Connect with the interface
-----------------------------------

Now you need to link your model to the interface. This is done by creating a class
that inherits from :code:`CompactBinaryCoalescenceGenerator`. The mininal set of ingredients
you need to provide in this class are a property :code:`metadata` and a function :code:`generate_td_modes`,
which should take the modes generated by your model and wrap the output into the :code:`GravitationalWaveModes`
class. This allows for easy access to the modes as TimeSeries, and polarization generation.

The conventions for the names and units of the parameters already built in the interface are provided in :ref:`Reference to standard GW parameters`. If one wants to use parameters not included in :ref:`Reference to standard GW parameters`, they need to be added to the metadata of the waveform model as explained in :ref:`Extra parameters`. The parent class :code:`CompactBinaryCoalescenceGenerator` provides a set of tools to ease the linking to your model.
Most importantly, you can check the correctness of the input parameter specifications
through the class' method :code:`parameter_check`, and transform your dictionary
of modes (say, each a numpy array) to a dictionary of :code:`gwpy.TimeSeries`
or :code:`gwpy.FrequencySeries` using :code:`to_gwpy_dict`.


Finally, you need to wrap the output the dictionary of modes and times/frequencies with the method :code:`gwsignal.core.gw.GravitationalWaveModes`
which allows for mode generation and computation of the polarizations given the extrinsic parameters. For gravitational wave polarizations, the outputs from generator can be returned
as TimeSeries or :code:`gwsignal.core.gw.GravitationalWavePolarizations` objects.

For the model to be called from :code:`lalsimulation.gwsignal.models.name_of_model`, the python script containing the class should be placed inside the folder :code:`gwsignal/models` and the name of the relevant script should be added to :code:`Makefile.am` inside the same folder.

.. code-block:: python

	from ..core import waveform as wave
	from ..core import gw as gw

	class MyModel(wave.CompactBinaryCoalescenceGenerator):

		def __init__(self, **kwargs):
			super(MyModel, self).__init__()

		@property
		def metadata(self):
			metadata = {
					"type": "non-precessing",
					"f_ref_spin": False,
					"modes": True,
					"polarizations": True,
					"implemented_domain": "time",
					"approximant" : 'template',
					"implementation" : "Python",
					"conditioning_routines" : 'gwsignal'
			}
			return metadata

		def generate_td_modes(self, **parameters):

			self.parameter_check(**parameters)
			times, h = my_modes(self.waveform_dict['mass1'], self.waveform_dict['mass2'])
			hlm = wave.to_gwpy_dict(h, times)

			return gw.GravitationalWaveModes(hlm)
