/**
\author Creighton, T. D.
\file
*/

/**

\heading{Module \ref StreamVectorSequenceInput.c}
\latexonly\label{ss_StreamVectorSequenceInput_c}\endlatexonly

Reads the entire contents of an input stream into a vector sequence.

\heading{Prototypes}












\heading{Description}

These routines read data from the I/O stream <tt>*stream</tt> until the
end-of-input is reached.  Each line is stored as a data vector, and
the vectors are combined into a LAL vector sequence structure
<tt>**sequence</tt>.  Each line vector is padded with zeros to match the
length of the longest line.  The routine passes back a pointer to the
new structure.

The routine <tt>LALCHARReadVectorSequence()</tt> essentially stores an
image of the I/O stream as a sequence of lines padded with <tt>'\0'</tt>
characters.  However, it will skip over any empty lines, which occur,
for instance, when the end-of-input or a null character <tt>'\0'</tt>
occurs immediately following a newline character <tt>'\n'</tt>.  The
numeric routines will additionally skip blank lines, comment lines, or
other input lines that have no parseable numbers in them.  (As with
the routines in \ref StreamVectorInput.c, comment in sindicated by a
<tt>#</tt> sign at the beginning of a line or a <tt>%</tt> sign anywhere
in the line, signifying that the remainder of the line is to be
ignored.)  However, if an input line contains \e any parseable
data, then the corresponding vector in the vector sequence will be
allocated (and padded with zeros, if it is shorter than the longest
line).

\heading{Algorithm}

These functions first create a linked list of vectors, using the
routines in \ref StreamVectorInput.c to read them in.  Once the list
is complete, the longest vector length is determined, and the vector
sequence is created and filled.

The numeric routines skip over blank, comment, or otherwise
unparseable lines by catching and handling the \c LEN error code
generated by the vector input routine.  However, it is worth pointing
out that the vector input routine will have generated an error message
if the error reporting bit in \c lalDebugLevel was set.  The
vector sequence input routines will therefore generate a followup
messages indicating that the preceding error was successfully dealt
with.  So you may see pairs of \c ABORT: and \c CONTINUE:
error messages when reading files containing blank or comment lines.

\heading{Uses}
\code
LALCalloc()         LALFree()
LALCHARReadVector() LALCHARDestroyVector() LALCHARCreateVectorSequence()
LALI2ReadVector()   LALI2DestroyVector()   LALI2CreateVectorSequence()
LALI4ReadVector()   LALI4DestroyVector()   LALI4CreateVectorSequence()
LALI8ReadVector()   LALI8DestroyVector()   LALI8CreateVectorSequence()
LALU2ReadVector()   LALU2DestroyVector()   LALU2CreateVectorSequence()
LALU4ReadVector()   LALU4DestroyVector()   LALU4CreateVectorSequence()
LALU8ReadVector()   LALU8DestroyVector()   LALU8CreateVectorSequence()
LALSReadVector()    LALSDestroyVector()    LALSCreateVectorSequence()
LALDReadVector()    LALDDestroyVector()    LALDCreateVectorSequence()
\endcode

\heading{Notes}



*/

#include <lal/LALStdlib.h>
#include <lal/AVFactories.h>
#include <lal/SeqFactories.h>
#include <lal/StreamInput.h>

NRCSID( STREAMVECTORSEQUENCEINPUTC, "$Id$" );

/* Define linked-list of pointers to vectors of arbitrary type. */
typedef union tagVector {
  CHARVector *CHV;
  INT2Vector *I2V;
  INT4Vector *I4V;
  INT8Vector *I8V;
  UINT2Vector *U2V;
  UINT4Vector *U4V;
  UINT8Vector *U8V;
  REAL4Vector *SV;
  REAL8Vector *DV;
} Vector;
typedef struct tagVectorList {
  Vector vector;
  struct tagVectorList *next;
} VectorList;

static const VectorList empty;


#define FREECHARVECTORLIST                                           \
do {                                                                 \
  if ( head.vector.CHV ) {                                           \
    TRY( LALCHARDestroyVector( stat->statusPtr,                      \
			     &(head.vector.CHV) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.CHV ) {                                        \
      TRY( LALCHARDestroyVector( stat->statusPtr,                    \
			       &(here->vector.CHV) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)


void
LALCHARReadVectorSequence( LALStatus          *stat,
			   CHARVectorSequence **sequence,
			   FILE               *stream )
{ 
  VectorList head = empty;   /* head of linked list of vectors */
  VectorList *here;          /* pointer to current position in list */
  CHAR *data;                /* pointer to vector data */
  UINT4 nRows, nCols;        /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALCHARReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALCHARReadVector( stat->statusPtr, &(head.vector.CHV), stream ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREECHARVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALCHARReadVector( stat->statusPtr, &(here->vector.CHV), stream );
    BEGINFAIL( stat ) {
      FREECHARVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine the maximum line length, and
     allocate the vector sequence.  Ignore lines containing only a
     single '\0' character. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.CHV->length > 1 ) {
      nRows++;
      if ( here->vector.CHV->length > nCols )
	nCols = here->vector.CHV->length;
    }
    here = here->next;
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALCHARCreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREECHARVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    UINT4 length = here->vector.CHV->length;
    if ( length > 1 ) {
      memcpy( data, here->vector.CHV->data, length );
      if ( nCols - length > 0 )
	memset( data + length, 0, nCols - length );
      data += nCols;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREECHARVECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}

#define TYPECODE I2
#define TYPE INT2
#define SIZE 2
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE I4
#define TYPE INT4
#define SIZE 4
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE I8
#define TYPE INT8
#define SIZE 8
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE U2
#define TYPE UINT2
#define SIZE 2
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE U4
#define TYPE UINT4
#define SIZE 4
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE U8
#define TYPE UINT8
#define SIZE 8
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE S
#define TYPE REAL4
#define SIZE 4
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE

#define TYPECODE D
#define TYPE REAL8
#define SIZE 8
#include "StreamVectorSequenceInput_source.c"
#undef TYPECODE
#undef TYPE
#undef SIZE
