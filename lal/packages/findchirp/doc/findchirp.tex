\newcommand{\ospsd}{\ensuremath{S\left(\left|f_{k}\right|\right)}}

\chapter{Package \texttt{findchirp}}

This package contains LAL routines to search for binary inspiral chirps using
templatated matched filtering and the $\chi^2$ veto. The findchirp package is
designed to allow the user to construct code to filter interferometer data and
produce a list of candidate inspiral events. It also contains functionality to
perform simulation and testing of the inspiral search. Conceptually the
package is divided into the following parts:

\begin{itemize}
\item Processing the raw interferometer input data into a form that can be
used for the filtering process.

\item Processing an inspiral chirp template into a form that can be used by
the filter, generating the chirp template internally, if necessary.

\item Using the processed input data, construction of a statistic on which to
search for chirps and searching for candidate events.

\item Constructing a veto statistic to apply to candidate events to reduce the
possibility of false alarms.

\end{itemize}

We introduce the conventions used in the package and then describe the theory
and implementation of the code. An overview of the package is as follows:
\begin{enumerate}
\item The header \texttt{FindChirpDatatypes.h} provides the core data types
definitions used by all the findchirp routines.

\item The header \texttt{FindChirp.h} and modules grouped therein provide the
core functionality of the package. This includes the code to perform matched
filtering and search for chirps with a signal to noise ratio above a given
threshold.  This header also provides an interface to inject time domain
waveforms so that various Monte Carlo simulations may be run using the same
code that is used to actually search for the chirps.

\item The header \texttt{FindChirpChisq.h} and associated module provide
functionality to perform a $\chi^2$ veto on candidate events generated by the
\texttt{FindChirpFilter()} function.

\item The header \texttt{FindChirpSP.h} provides functionality needed to
filter interferometer data using second order post-Newtonian inspiral chirps
generated by the stationary phase approximation to the inspiral waveform.

\item The header \texttt{FindChirpTD.h} provides functionality to filter
interferometer data using TaylorT1, TaylorT2 or TaylorT3 time domain waveforms
generated by the inspiral package.

\item The header \texttt{FindChirpBCV.h} provides functionality to filter
interferometer data using the BCV detection template family.

\item The header \texttt{FindChirpBCVSpin.h} provides functionality to filter
interferometer data using the BCV detection template family.

\item The header \texttt{FindChirpFilterOutputVeto.h} provides prototypes for
implementing various additional signal-based vetoes.
\end{enumerate}

\newpage

\section{Conventions}

We follow the standards for LSC code in the LIGO technical note T010095.  All
the findchirp functions measure mass in units of $M_\odot$ and time in units
of seconds.

\subsection{Conventions for Discrete Quantities}
\label{ss:conventions}

The raw output of the interferometer is the error signal from the length
sensing and control servo, LSC-AS\_Q.  Although this signal is a dimensionless
quantity, we say that it has units of ``counts'' and we denote it by $v(t)$.
The calibrated detector output is related to the raw detector output by the
detector response function according
to \begin{equation}
\tilde{s}(f) = R(f;t) \tilde{v}(f)
\end{equation}
where $R(f;t)$ is the (complex) response function of the detector at time $t$
and has units of strain/count.  In practice, the interferometer output is a
discretely sampled quantity with sampling interval $\Delta t$, that is $v_j
\equiv v(t_j)$ where $t_j = j\Delta t$.  The digital matched filter operates
on a single \emph{data segment} consisting of $N$ consecutive samples of
$v(t_j)$. The length of this data segment is $T = N\Delta t$~seconds.
Henceforth, we let $N$ be a power of $2$ and follow the convention that the
subscript $j$ refers to discretely sampled time domain quantities and the
subscript $k$ to discretely sampled frequency domain quantities.  The
frequency domain quantity $\tilde{v}(f_k)$ denotes the value of the continuous
function $\tilde{v}(f)$ at a particular frequency, labeled $f_k = k/(N\Delta
t)$. If the units of $v_j$ are counts, then $\tilde{v}(f_k)$ has units of
counts/Hz. We define the quantity $\tilde{v}_k$ by $\tilde{v}_k =
\tilde{v}(f_k) / \Delta t$, which has units of counts. If $k$ is negative,
this corresponds to negative frequencies.

\subsection{The Discrete Fourier Transform}
\label{ss:dft}

If $v(t_j)$ is sampled at intervals of $\Delta t$, then the sampling theorem
tells us that $v(t_j)$ is bandwidth limited to the frequency range
$-f_\mathrm{Ny} \le f \le f_\mathrm{Ny}$, where
\begin{equation}
f_\mathrm{Ny} = \frac{1}{2\Delta t}
\end{equation}
is the \emph{Nyquist critical frequency}. Any power in $v(t)$ at frequencies
above $f_\mathrm{Ny}$ will be aliased into the range $-f_\mathrm{Ny} \le f
\le f_\mathrm{Ny}$, corrupting the signal. To prevent this, signals of
frequency higher than $f_\mathrm{Ny}$ in the interferometer output are removed
using analog low-pass filters before the signal is digitized. Therefore
$v(t_j)$ completely determines the signal $v(t)$ in the band of interest. We
may approximate the Fourier transform of this band limited signal $v(t_j)$ by
\begin{equation}
\tilde{v}(f_k) \rightarrow \sum_{j=0}^{N-1} \Delta t\, v(t_j) e^{-2 \pi i f_k t_j}
= \Delta t \sum_{j=0}^{N-1} v_j e^{-2 \pi i j k / N},
\label{eq:fftapprox}
\end{equation}
where $-(N/2 + 1) \le k \le N/2$ and the symbol $\rightarrow$ means
equal to under discretization.  Notice that the approximation to the
Fourier transform is periodic in $k$ with period $N$ and so 
\begin{equation}
\tilde{v}_{-k} = \tilde{v}_{N-k}\quad k = 1, \ldots, N - 1.
\end{equation}
Thus we let $k$ vary from $0$ to $N-1$ where zero frequency (DC) corresponds
to $k=0$, positive frequencies $0 < f < f_\mathrm{Ny}$ to values in the range
$0 < k < N/2$ and negative frequencies $-f_\mathrm{Ny} < f < 0$ correspond
to values in the range $N/2 < k < N$. The value $k = N/2$ approximates the
value of the Fourier transform at both $-f_\mathrm{Ny}$ and $f_\mathrm{Ny}$;
both these values are equal due to the periodicity of the discrete transform 
defined by
\begin{equation}
\tilde{v}_k = \sum_{j=0}^{N-1} v_j e^{-i 2 \pi j k / N}.
\label{eq:dftdef}
\end{equation}
We may estimate the discrete inverse Fourier transform
in a similar way, using the relation
\begin{equation}
\Delta f = f_{k+1} - f_k = \frac{k+1}{N\Delta t} - \frac{k}{N\Delta t} =
\frac{1}{N\Delta t}
\end{equation}
to obtain
\begin{equation}
v_j = \frac{1}{N} \sum_{k=0}^{N-1} \tilde{v}_k e^{2 \pi i j k / N}.
\end{equation}

\subsection{Power Spectral Densities}
\label{ss:psdconv}

The one sided power spectral density $S_n(|f|)$ of $n(t)$ to be 
\begin{equation}
\left\langle\tilde{n}(f) \tilde{n}^\ast(f')\right\rangle = 
\frac{1}{2}S_n(|f|)\delta(f-f')
\end{equation}
where angle brackets denote an average over different realizations of the noise.
If $n(t)$ has units of $U$ then $\tilde{n}(f)$ has units of
$(\mathrm{time}) \times U$. The units $\delta(f-f')$ are $(\mathrm{time})$,
since 
\begin{equation}
\int_{-\infty}^\infty \delta(f)\,df = 1
\end{equation}
is a dimensionless quantity and $df$ has units $(\mathrm{time})^{-1}$.
Therefore we see that $S_n(|f|)$ has units of $(\mathrm{time})\times U^2$.
If we replace $\tilde{n}(f_k)$ with the discretely sampled quantities 
$\tilde{n}_k = \tilde{n}(f_k)$, we obtain
\begin{equation}
\left\langle\tilde{n}_k \tilde{n}_{k'}^\ast\right\rangle = 
\frac{N}{2\Delta t}\ospsd\delta_{kk'}
\label{eq:ospsddisc}
\end{equation}
where $\delta_{kk'}$ is the dimensionless Kronecker $\delta$-function,
obtained by discretization of the continuous $\delta$-function:
\begin{equation}
\delta(f-f') \rightarrow N\Delta t\delta_{kk'}
\end{equation}
Equation (\ref{eq:ospsddisc}) defines \ospsd in terms of the discrete
frequency domain quantities. 

\newpage\input{FindChirpDatatypesH}
\newpage\input{FindChirpH}
\newpage\input{FindChirpSPH}
\newpage\input{FindChirpTDH}
\newpage\input{FindChirpChisqH}
\newpage\input{FindChirpFilterOutputVetoH}
\newpage\input{FindChirpBCVH}
\newpage\input{FindChirpBCVSpinH}
