#!@PYTHONPROG@
#
# Copyright (C) 2013  Leo Singer
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
from __future__ import division
from __future__ import print_function
"""
Match sky maps with injections in an inspinjfind-style sqlite database and print
summary values for each sky map:

 * event ID
 * false alarm rate
 * searched area
 * searched posterior probability
 * angle between true sky location and maximum a posteriori estimate
 * runtime in seconds

The filenames of the sky maps may be provided as positional command line
arguments, and may also be provided as globs (such as '*.fits.gz').
"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


if __name__ == '__main__':
    # Command line interface.
    from optparse import Option, OptionParser
    from lalinference.bayestar import command

    parser = OptionParser(
        formatter=command.NewlinePreservingHelpFormatter(),
        description=__doc__,
        usage="%prog [-o OUTPUT] DATABASE.sqlite FILE1.fits[.gz] FILE2.fits[.gz] ...",
        option_list=[
            Option("-o", "--output", default="/dev/stdout",
                help="Name of output file [default=%default]"),
            Option("-j", "--jobs", default=1, type=int,
                help="Number of threads [default=%default]")
        ]
    )
    opts, args = parser.parse_args()

    try:
        dbfilename = args[0]
        fitsfileglobs = args[1:]
    except IndexError:
        parser.error("not enough command line arguments")

    outfile = open(opts.output, "w")

# Imports.
import glob
import functools
import itertools
import sqlite3
from pylal.progress import ProgressBar
from lalinference.bayestar import fits
from lalinference.bayestar import postprocess


sql = """
SELECT DISTINCT sim.longitude AS ra, sim.latitude AS dec, ci.combined_far AS far
FROM coinc_event_map AS cem1 INNER JOIN coinc_event_map AS cem2
ON (cem1.coinc_event_id = cem2.coinc_event_id)
INNER JOIN sim_inspiral AS sim ON (cem1.event_id = sim.simulation_id)
INNER JOIN coinc_inspiral AS ci ON (cem2.event_id = ci.coinc_event_id)
WHERE cem1.table_name = 'sim_inspiral' AND cem2.table_name = 'coinc_event'
AND cem2.event_id = ?"""


def startup(dbfilename):
    global db
    db = sqlite3.connect(dbfilename)


def process(fitsfilename):
    sky_map, metadata = fits.read_sky_map(fitsfilename)

    coinc_event_id = metadata['objid']
    try:
        runtime = metadata['runtime']
    except KeyError:
        runtime = None

    true_ra, true_dec, far = db.execute(sql, (coinc_event_id,)).fetchone()
    searched_area, searched_prob, offset = postprocess.find_injection(
        sky_map, true_ra, true_dec)

    return coinc_event_id, far, searched_area, searched_prob, offset, runtime


if __name__ == '__main__':
    if opts.jobs == 1:
        from itertools import imap
        startup(dbfilename)
    else:
        import multiprocessing
        imap = multiprocessing.Pool(opts.jobs, startup, (dbfilename,)).imap_unordered

    progress = ProgressBar()

    progress.update(-1, 'obtaining filenames of sky maps')
    fitsfilenames = tuple(itertools.chain.from_iterable(glob.iglob(fitsfileglob)
        for fitsfileglob in fitsfileglobs))

    print('objid', 'far', 'searched_area', 'searched_prob', 'offset', 'runtime',
        sep=',', file=outfile)

    count_records = 0
    progress.max = len(fitsfilenames)
    for record in imap(functools.partial(process), fitsfilenames):
        count_records += 1
        progress.update(count_records, record[0])
        print(*record, sep=',', file=outfile)
